<center>线程池、死锁、线程状态、等待与唤醒、
Lambda表达式、Stream流</center>

## 今日内容

+ 线程池
  + Executor
  + ExecutorService
  + Executors
+ 死锁
+ 线程的状态
  + wait()等待
  + notify()唤醒
+ 定时器Timer







## 第一章 线程池方法

### 1.思想

我们之前使用多线程每次使用线程时都会创建一个新的线程，然后使用该线程去执行任务，这个线程执行完任务后就会销毁（退出）。这样频繁创建以及销毁线程对性能的影响是非常大的。
如果要解决这个问题，我们可以预先创建很多线程然后将这些线程放到一个容器中，如果以后要使用线程，直接从这个容器中获取线程，然后使用。如果用完了这个线程，那么就再把这个线程给放回去。以后再使用线程，直接从这个容器中拿即可。这样就避免了频察创建以及销级线程带来的性能问题。

这个容器java已经为我们提供,就是线程池。线程池就是一个容器，里面已经创建好许多线程，如果我们要使用，直接通过线程池去使用即可。

![](https://p.pstatp.com/origin/137ac00009a43f16a282c)

### 2.概念

其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源。

```java
线程池就是一个容器，里面有很多线程，里面的每一个线程都可以去多次执行任务。

线程池相关API
    Executor:接口，该接收是线程池的根接口。这个接口中提供了提交线程任务的方法。
    ExecutorService：是Executor的子接口，也表示线程池。里面除了提供了执行线程任务的方法，还提供了管理线程池的方法
    Executors：线程的工具类。里面提供获取线程池的方法。

注意：线程池不是我们自己创建的。而是通过Execcutors进行获取的。

Executors获取线程池的方法：
    static ExecutorService newFixedThreadpool(int nThreads):创建一个定长的线程池，参数表示线程池的长度。

 ExecutorService表示线程池，里面有一些方法。
    submit(Runnable task):提交线程任务并执行.
    shutdown():销毁线程池.
```

### 3.使用[掌握]

```java
线程池的使用步骤：
1.调用Executors的newFixedThreadPooL方法获取线程池。
2.定义一个Runnable实现类，表示线程任务
3.通过线程池调用submit,传递Runnable接口的实现类对象，执行线程任务。
4.销毁线程池(一般不做,频繁创建销毁对性能影响更大)

线程池创建的线程索引从1开始
```

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo01ThreadPool {
    public static void main(String[] args) {
        // 调用Executors的newFixedThreadPooL方法获取线程池。
        // 长度为2
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        // 定义一个Runnable实现类，表示线程任务
        Task task = new Task();
        // 通过线程池调用submit,传递Runnable接口的实现类对象，执行线程任务。
        threadPool.submit(task);
        threadPool.submit(task);
        threadPool.submit(task);//等线程空闲出来再执行

        // 销毁线程池
        threadPool.shutdown();


    }
}
```

### 4.多线程的第三种实现方式(了解)

步骤：
    1.定义类，然后实现Callable接口。
    2.重写Callable接口中的caLL方法，在caLL方法中定义线程要执行的任务
    3.获取一个线程池【该方式完成多线程必须要有线程池】
    4.调用线程池的submit方法，传递CaLLabLe接口的实现类对象，执行线程任务。
    5.处理结果
线程池的submit方法:
    Future submit(Callable task):提交线程任务。返回值Future类型，表示将来线程运行后产出的结果。
Future里面封装了线程执行后的结果：
    V get():获取线程执行结果[如果线程没有执行结束,get方法就会等着线程执行完毕]

```java
// 实现接口
import java.util.concurrent.Callable;

public class CallableImpl implements Callable<String> {
    // call方法中定义线程要执行的任务，该方法的返回值就是线程执行后产出的结果。
    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println("helloworld");
        }
        return "执行完成";
    }
}
// 测试类
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Demo01Callable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 获取一个线程池
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        // 调用线程池的submit方法，传递CaLLabLe接口的实现类对象，执行线程任务。
        Future<String> future = threadPool.submit(new CallableImpl());
        // 调用get方法获取返回值
        String s = future.get();
        System.out.println(s);


    }
}
```

## 第二章 死锁

### 1.介绍

#### 1.1什么是死锁

多个线程各自持有锁且等待其他线程释放锁.

在多线程程序中,使用了多把锁,造成线程之间相互等待，程序不往下走了。

#### 1.2死锁产生的条件

1.有多把锁 2.有多个线程 3.有同步代码块嵌套

### 2.死锁演示

+ 锁类

```java
public class Locks {
    // 创建2给对象,表示2个锁
    public  static  Object locka = new Object();
    public  static  Object lockb = new Object();

}
```

+ 进程类

```java
public class MyThreadA extends Thread{
    @Override
    public void run() {
        synchronized (Locks.locka){
            System.out.println("A进程------a");
            synchronized (Locks.lockb){
            System.out.println("A进程-----b");}
        }
    }
}
public class MyThreadB extends Thread{
    @Override
    public void run() {
        synchronized (Locks.lockb){
            System.out.println("B进程------b");
            synchronized (Locks.locka){
            System.out.println("B进程-----a");}
        }
    }
}

```

+ 测试类

```java
public class Demo01Test {
    public static void main(String[] args) {
        new MyThreadA().start();
        new MyThreadB().start();
    }
}
// 结果
/*
B进程------b
A进程------a
(程序未结束,且不是每次执行都会出现死锁情况)
*/
```

## 第三章 线程状态

### 1.概述

线程由生到死的完整过程：技术素养和面试的要求。 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：
这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析

| 序号 | 线程状态                 | 导致状态发生条件                                             |
| ---- | ------------------------ | ------------------------------------------------------------ |
| 1    | 新建(NEW)                | 刚刚创建出来并没有调用start方法启动的线程处于新建状态。      |
| 2    | 运行（RUNNABLE)          | 线程调用start方法会处于运行的状态。                          |
| 3    | 受阻塞（BLOCKED)         | 等待获取锁的线程处于受阻塞的状态。                           |
| 4    | 无限等待（WAITING)       | 当线程调用wait()方法后，处于无限等待状态【没有时间的等待，别人不叫我，我就一直等】 |
| 5    | 计时等待（TIMED_WAITING) | 当线程调用sleep(毫秒）,wait(毫秒值）会进入到计时等待【有时间的等待，到了时间别人不叫我，我也会醒】 |
| 6    | 退出（TERMINATED)        | 如果线程执行完了run方法，或者线程调用了stop方法              |

![](https://p.pstatp.com/origin/ff4d0002ed220129ebeb)

### 2.等待唤醒机制

```java
在object中，有两种方法可以让线程等待以及喷醒线程。
    void wait():让线程等待，直到有其他线程唤醒他。
    void wait(long timeout):让线程等待，直到有其他线程唤醒他，或者时间到了也会自己醒。
    void notify():唤醒一个等待的线程
    void notifyALL():唤醒所有等待的线程。
    wait方法用于等待，notify方法用于唤醒，他们一起使用，一般叫做等待唤醒机制，一般用于线程间的通信。

    wait notify 是object中的方法
    wait notify（同步代码块或同步方法）,通过锁对象去调用。
    
    通过哪个锁调用的notify,那么唤醒的就是通过哪个锁调用的wait等待的进程
```

#### 吃包子案例

定义一个集合，包子铺线程完成生产包子，包子添加到集合中；吃货线程完成购买包子，包子从集合中移除。

1. 当包子没有时（包子状态为false），吃货线程等待。

2. 包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）

```java
/*
包子类
 */
public class BaoZi {
    // 属性,包子是否存在
    boolean flag = false;
}
```

```java
// 包子铺
public class BaoZiPu extends Thread {
    //铺要使用包子，包子铺使用的包子要和吃货使用的包子是同一个。所以定义Baozi类型的变量，然后通过构造方法的方式传递进来包子对象
    private BaoZi baozi;
    // 定义构造方法,接收传递进来的包子,把他赋值给baozi
    public BaoZiPu(BaoZi baozi) {
        this.baozi = baozi;
    }
    // 定义线程任务
    // 对于包子普来说,任务一直生成包子,等着吃货吃
    @Override
    public void run() {
        // 死循环代表一直生产包子
        while (true){
            // 包子铺和吃货都有操作包子,使用线程同步保证线程安全
            // 包子是唯一的,所以用作锁
            synchronized (baozi){
                // 如果有包子,等着吃货吃包子
                if (baozi.flag){
                    // 等待[wait方法通过锁调用]
                    try {
                        baozi.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 如果没有包子,包子铺就要生成包子
                System.out.println("生产一个大包子");
                // 更改标记
                baozi.flag=true;
                // 叫醒吃货进程,执行吃包子任务
                baozi.notify();
            }
        }
    }
}
```

```java
// 吃货
public class ChiHuo extends Thread {
    private BaoZi baoZi;

    public ChiHuo(BaoZi baoZi) {

        this.baoZi = baoZi;
    }
    // 定义线程要执行的任务
    // 对于本类来说,任务就是chibaoz,等着包子铺蒸包子
    @Override
    public void run() {
        // 一直吃,用死循环
        while (true){
            // 吃货和包子铺操作的是同一个包子
            synchronized (baoZi){
                // 如果没有包子,吃货要等着生产包子
                if (!baoZi.flag){
                    // 调用wait方法等待
                    try {
                        baoZi.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 如果有包子,要吃包子
                System.out.println("吃了一个包子");
                // 更改标记
                baoZi.flag=false;
                // 叫醒包子铺进程
                baoZi.notify();

            }
        }
    }
}
```

```java
// 测试类
public class Demo01Test {
    public static void main(String[] args) {
       // 创建包子
        BaoZi baoZi = new BaoZi();
        // 创建包子铺和吃货线程
        new BaoZiPu(baoZi).start();
        new ChiHuo(baoZi).start();
    }
}
```

`注意`

当线程调用wait方法后会等待,并且释放自己的锁.

wait:会释放自己的锁; sleep:不会释放锁.

## 第四章 定时器

```java
Timer类，表示定时器，可以只执行一次，也可以周期性的执行
Timer的构造方：
    Timer():空参数的构造方法

其他方法:
    void schedule(TimerTask task, Long delay):指定毫秒值【deLay】后，执行任务【task】，只执行一次
    void schedule(TimerTask task, Long delay,long period):指定毫秒值【deLay】后，执行任务【task】,该方法会周期性执行任务,每隔【period】执行一次.
    void schedule(TimerTask task, Date time): 安排定时器在指定时间【time】执行任务【task】
    void schedule(TimerTask task, Date time,long period): 安排定时器在指定时间【time】执行任务【task】,该方法会周期性执行任务,每隔【period】执行一次.
```

```java
import java.util.Calendar;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class Demo01Timer {
    public static void main(String[] args) {
        // 创建定时器对象
        Timer t = new Timer();
        // 设置定时器,1秒后启动,输出内容
        t.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("叮咚");
            }
        },1000);
        System.out.println("XXXX");
        // 设置定时器,2秒后启动,输出内容,每秒执行一次
        t.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("biubiubiu");
            }
        },2000,1000);
        // 设置定时器,指定时间执行一次.
        Calendar c = Calendar.getInstance();
        c.set(Calendar.HOUR_OF_DAY,11);
        c.set(Calendar.MINUTE,42);
        c.set(Calendar.SECOND,30);
        // 转成时间对象
        Date date = c.getTime();
        // 设置定时,在指定时间执行
        t.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("指定时间到了");
            }
        },date);
    }
}
```



## 第五章 Lambda表达式

### 1.冗余的匿名内部类

```java
匿名内部类中有很多代码是冗余的
匿名内部类完成多线程的案例中
因为Thread构造方法中需要传递Runnable接口的实现类对象，所以不得不写了new Runnable
因为置名内部类中需要重写方法，重写方法时要求方法的声明部分一模一样，所以不得不写了public void run

整个匿名内部类中最重要的是方法的参数,方法体,返回值.
匿名内部类很多东西都是多余的，所以我们最好的情况就是只关注参数，方法体，返回值这三个关键字。
   
如果使用Lambda表达式，可以关注最核心的内容（参数，方法体，返回值）,解决了匿名内部类的元余。
lambda是匿名内部类的简化写法.
lambda表达式使用的是函数式编程思想
面向对象思想：怎么
函数式编程思想：做什么
```

```java
public class Demo01Inner {
    public static void main(String[] args) {
        // 使用匿名内部类的方法创建多线程

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "执行了");
            }
        }).start();
        // lambda表达式初体验
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "执行了");
        }).start();
    }
}
```

### 2.Lambda表达式的标准格式





### 3.Lambda表达式比较器





### 4.Lambda表达式简化写法





### 5.Lambda表达式使用前提







## 第六章 Stream







## 总结







































