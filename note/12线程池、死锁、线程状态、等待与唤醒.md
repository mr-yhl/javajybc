<center>线程池、死锁、线程状态、等待与唤醒、
Lambda表达式、Stream流</center>

## 今日内容

+ 线程池
  + Executor
  + ExecutorService
  + Executors
+ 死锁
+ 线程的状态
  + wait()等待
  + notify()唤醒
+ 定时器Timer







## 第一章 线程池方法

### 1.思想

我们之前使用多线程每次使用线程时都会创建一个新的线程，然后使用该线程去执行任务，这个线程执行完任务后就会销毁（退出）。这样频繁创建以及销毁线程对性能的影响是非常大的。
如果要解决这个问题，我们可以预先创建很多线程然后将这些线程放到一个容器中，如果以后要使用线程，直接从这个容器中获取线程，然后使用。如果用完了这个线程，那么就再把这个线程给放回去。以后再使用线程，直接从这个容器中拿即可。这样就避免了频察创建以及销级线程带来的性能问题。

这个容器java已经为我们提供,就是线程池。线程池就是一个容器，里面已经创建好许多线程，如果我们要使用，直接通过线程池去使用即可。

![](https://p.pstatp.com/origin/137ac00009a43f16a282c)

### 2.概念

其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源。

```java
线程池就是一个容器，里面有很多线程，里面的每一个线程都可以去多次执行任务。

线程池相关API
    Executor:接口，该接收是线程池的根接口。这个接口中提供了提交线程任务的方法。
    ExecutorService：是Executor的子接口，也表示线程池。里面除了提供了执行线程任务的方法，还提供了管理线程池的方法
    Executors：线程的工具类。里面提供获取线程池的方法。

注意：线程池不是我们自己创建的。而是通过Execcutors进行获取的。

Executors获取线程池的方法：
    static ExecutorService newFixedThreadpool(int nThreads):创建一个定长的线程池，参数表示线程池的长度。

 ExecutorService表示线程池，里面有一些方法。
    submit(Runnable task):提交线程任务并执行.
    shutdown():销毁线程池.
```

### 3.使用[掌握]

```java
线程池的使用步骤：
1.调用Executors的newFixedThreadPooL方法获取线程池。
2.定义一个Runnable实现类，表示线程任务
3.通过线程池调用submit,传递Runnable接口的实现类对象，执行线程任务。
4.销毁线程池(一般不做,频繁创建销毁对性能影响更大)

线程池创建的线程索引从1开始
```

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo01ThreadPool {
    public static void main(String[] args) {
        // 调用Executors的newFixedThreadPooL方法获取线程池。
        // 长度为2
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        // 定义一个Runnable实现类，表示线程任务
        Task task = new Task();
        // 通过线程池调用submit,传递Runnable接口的实现类对象，执行线程任务。
        threadPool.submit(task);
        threadPool.submit(task);
        threadPool.submit(task);//等线程空闲出来再执行

        // 销毁线程池
        threadPool.shutdown();


    }
}
```

### 4.多线程的第三种实现方式(了解)

步骤：
    1.定义类，然后实现Callable接口。
    2.重写Callable接口中的caLL方法，在caLL方法中定义线程要执行的任务
    3.获取一个线程池【该方式完成多线程必须要有线程池】
    4.调用线程池的submit方法，传递CaLLabLe接口的实现类对象，执行线程任务。
    5.处理结果
线程池的submit方法:
    Future submit(Callable task):提交线程任务。返回值Future类型，表示将来线程运行后产出的结果。
Future里面封装了线程执行后的结果：
    V get():获取线程执行结果[如果线程没有执行结束,get方法就会等着线程执行完毕]

```java
// 实现接口
import java.util.concurrent.Callable;

public class CallableImpl implements Callable<String> {
    // call方法中定义线程要执行的任务，该方法的返回值就是线程执行后产出的结果。
    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println("helloworld");
        }
        return "执行完成";
    }
}
// 测试类
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Demo01Callable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 获取一个线程池
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        // 调用线程池的submit方法，传递CaLLabLe接口的实现类对象，执行线程任务。
        Future<String> future = threadPool.submit(new CallableImpl());
        // 调用get方法获取返回值
        String s = future.get();
        System.out.println(s);


    }
}
```

## 第二章 死锁

### 1.介绍

#### 1.1什么是死锁

多个线程各自持有锁且等待其他线程释放锁.

在多线程程序中,使用了多把锁,造成线程之间相互等待，程序不往下走了。

#### 1.2死锁产生的条件

1.有多把锁 2.有多个线程 3.有同步代码块嵌套

### 2.死锁演示

+ 锁类

```java
public class Locks {
    // 创建2给对象,表示2个锁
    public  static  Object locka = new Object();
    public  static  Object lockb = new Object();

}
```

+ 进程类

```java
public class MyThreadA extends Thread{
    @Override
    public void run() {
        synchronized (Locks.locka){
            System.out.println("A进程------a");
            synchronized (Locks.lockb){
            System.out.println("A进程-----b");}
        }
    }
}
public class MyThreadB extends Thread{
    @Override
    public void run() {
        synchronized (Locks.lockb){
            System.out.println("B进程------b");
            synchronized (Locks.locka){
            System.out.println("B进程-----a");}
        }
    }
}

```

+ 测试类

```java
public class Demo01Test {
    public static void main(String[] args) {
        new MyThreadA().start();
        new MyThreadB().start();
    }
}
// 结果
/*
B进程------b
A进程------a
(程序未结束,且不是每次执行都会出现死锁情况)
*/
```

## 第三章 线程状态

### 1.概述

线程由生到死的完整过程：技术素养和面试的要求。 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：
这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析

| 序号 | 线程状态                 | 导致状态发生条件                                             |
| ---- | ------------------------ | ------------------------------------------------------------ |
| 1    | 新建(NEW)                | 刚刚创建出来并没有调用start方法启动的线程处于新建状态。      |
| 2    | 运行（RUNNABLE)          | 线程调用start方法会处于运行的状态。                          |
| 3    | 受阻塞（BLOCKED)         | 等待获取锁的线程处于受阻塞的状态。                           |
| 4    | 无限等待（WAITING)       | 当线程调用wait()方法后，处于无限等待状态【没有时间的等待，别人不叫我，我就一直等】 |
| 5    | 计时等待（TIMED_WAITING) | 当线程调用sleep(毫秒）,wait(毫秒值）会进入到计时等待【有时间的等待，到了时间别人不叫我，我也会醒】 |
| 6    | 退出（TERMINATED)        | 如果线程执行完了run方法，或者线程调用了stop方法              |

![](https://p.pstatp.com/origin/ff4d0002ed220129ebeb)

### 2.等待唤醒机制

```java
在object中，有两种方法可以让线程等待以及喷醒线程。
    void wait():让线程等待，直到有其他线程唤醒他。
    void wait(long timeout):让线程等待，直到有其他线程唤醒他，或者时间到了也会自己醒。
    void notify():唤醒一个等待的线程
    void notifyALL():唤醒所有等待的线程。
    wait方法用于等待，notify方法用于唤醒，他们一起使用，一般叫做等待唤醒机制，一般用于线程间的通信。

    wait notify 是object中的方法
    wait notify（同步代码块或同步方法）,通过锁对象去调用。
    
    通过哪个锁调用的notify,那么唤醒的就是通过哪个锁调用的wait等待的进程
```

#### 吃包子案例

定义一个集合，包子铺线程完成生产包子，包子添加到集合中；吃货线程完成购买包子，包子从集合中移除。

1. 当包子没有时（包子状态为false），吃货线程等待。

2. 包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）

```java
/*
包子类
 */
public class BaoZi {
    // 属性,包子是否存在
    boolean flag = false;
}
```

```java
// 包子铺
public class BaoZiPu extends Thread {
    //铺要使用包子，包子铺使用的包子要和吃货使用的包子是同一个。所以定义Baozi类型的变量，然后通过构造方法的方式传递进来包子对象
    private BaoZi baozi;
    // 定义构造方法,接收传递进来的包子,把他赋值给baozi
    public BaoZiPu(BaoZi baozi) {
        this.baozi = baozi;
    }
    // 定义线程任务
    // 对于包子普来说,任务一直生成包子,等着吃货吃
    @Override
    public void run() {
        // 死循环代表一直生产包子
        while (true){
            // 包子铺和吃货都有操作包子,使用线程同步保证线程安全
            // 包子是唯一的,所以用作锁
            synchronized (baozi){
                // 如果有包子,等着吃货吃包子
                if (baozi.flag){
                    // 等待[wait方法通过锁调用]
                    try {
                        baozi.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 如果没有包子,包子铺就要生成包子
                System.out.println("生产一个大包子");
                // 更改标记
                baozi.flag=true;
                // 叫醒吃货进程,执行吃包子任务
                baozi.notify();
            }
        }
    }
}
```

```java
// 吃货
public class ChiHuo extends Thread {
    private BaoZi baoZi;

    public ChiHuo(BaoZi baoZi) {

        this.baoZi = baoZi;
    }
    // 定义线程要执行的任务
    // 对于本类来说,任务就是chibaoz,等着包子铺蒸包子
    @Override
    public void run() {
        // 一直吃,用死循环
        while (true){
            // 吃货和包子铺操作的是同一个包子
            synchronized (baoZi){
                // 如果没有包子,吃货要等着生产包子
                if (!baoZi.flag){
                    // 调用wait方法等待
                    try {
                        baoZi.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 如果有包子,要吃包子
                System.out.println("吃了一个包子");
                // 更改标记
                baoZi.flag=false;
                // 叫醒包子铺进程
                baoZi.notify();

            }
        }
    }
}
```

```java
// 测试类
public class Demo01Test {
    public static void main(String[] args) {
       // 创建包子
        BaoZi baoZi = new BaoZi();
        // 创建包子铺和吃货线程
        new BaoZiPu(baoZi).start();
        new ChiHuo(baoZi).start();
    }
}
```

`注意`

当线程调用wait方法后会等待,并且释放自己的锁.

wait:会释放自己的锁; sleep:不会释放锁.

## 第四章 定时器

```java
Timer类，表示定时器，可以只执行一次，也可以周期性的执行
Timer的构造方：
    Timer():空参数的构造方法

其他方法:
    void schedule(TimerTask task, Long delay):指定毫秒值【deLay】后，执行任务【task】，只执行一次
    void schedule(TimerTask task, Long delay,long period):指定毫秒值【deLay】后，执行任务【task】,该方法会周期性执行任务,每隔【period】执行一次.
    void schedule(TimerTask task, Date time): 安排定时器在指定时间【time】执行任务【task】
    void schedule(TimerTask task, Date time,long period): 安排定时器在指定时间【time】执行任务【task】,该方法会周期性执行任务,每隔【period】执行一次.
```

```java
import java.util.Calendar;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class Demo01Timer {
    public static void main(String[] args) {
        // 创建定时器对象
        Timer t = new Timer();
        // 设置定时器,1秒后启动,输出内容
        t.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("叮咚");
            }
        },1000);
        System.out.println("XXXX");
        // 设置定时器,2秒后启动,输出内容,每秒执行一次
        t.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("biubiubiu");
            }
        },2000,1000);
        // 设置定时器,指定时间执行一次.
        Calendar c = Calendar.getInstance();
        c.set(Calendar.HOUR_OF_DAY,11);
        c.set(Calendar.MINUTE,42);
        c.set(Calendar.SECOND,30);
        // 转成时间对象
        Date date = c.getTime();
        // 设置定时,在指定时间执行
        t.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("指定时间到了");
            }
        },date);
    }
}
```



## 第五章 Lambda表达式

### 1.冗余的匿名内部类

```java
匿名内部类中有很多代码是冗余的
匿名内部类完成多线程的案例中
因为Thread构造方法中需要传递Runnable接口的实现类对象，所以不得不写了new Runnable
因为置名内部类中需要重写方法，重写方法时要求方法的声明部分一模一样，所以不得不写了public void run

整个匿名内部类中最重要的是方法的参数,方法体,返回值.
匿名内部类很多东西都是多余的，所以我们最好的情况就是只关注参数，方法体，返回值这三个关键字。
   
如果使用Lambda表达式，可以关注最核心的内容（参数，方法体，返回值）,解决了匿名内部类的元余。
lambda是匿名内部类的简化写法.
lambda表达式使用的是函数式编程思想
面向对象思想：怎么
函数式编程思想：做什么
```

```java
public class Demo01Inner {
    public static void main(String[] args) {
        // 使用匿名内部类的方法创建多线程

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "执行了");
            }
        }).start();
        // lambda表达式初体验
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "执行了");
        }).start();
    }
}
```

### 2.Lambda表达式的标准格式

```java
匿名内部类格式:
    new 父类或接口(){
        重写方法
    }
匿名内部类有很多东西是元余的，整个匿名内部类中最核心的东西是方法的参数，方法体，以及方法的返回值。
最好的情况是关注方法的参数，方法体，以及方法的返回值这三点。
如果使用Lambda表达式只需要关注方法参数，方法体，以及返回值。
Lambda标准格式：
        (参数类型 参数名) -> {
            方法体;
            return 返回值;
        }
    格式解释：
        1. 小括号中的参数和之前传统方法参数写法一样，如果有多个参数，使用逗号隔开。
        2. ->是一个运算符，表示指向性动作。
        3. 大括号中的内容之前传统方法大括号中的内容写法一样的。

Lambda表达式可以省去面向对象中的条条框框，让我们只关注最核心的内容。
Lambda表达式是函数式编程思想，函数式编程思想中，可推导，就是可省略。

因为在Thread的构造方法中需要传递Runnable接口类型的参数，所以可以省略new Runnable。
因为Runnable中只有一个抽象方法叫做run，所以在重写该方法时可以省略public void run
```

```java
public class Demo02Lambda {
    public static void main(String[] args) {
        // 使用匿名内部类的方法创建多线程

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "执行了");
            }
        }).start();

        // 使用lambda标准格式完成多线程
        new Thread(()->{
            System.out.println(Thread.currentThread().getName() + "执行了");
        }).start();
    }
}
```

### 3.Lambda表达式比较器

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/*
使用比较器排序对Person对象根据年龄排序
 */
public class Demo03Collection {
    public static void main(String[] args) {
        //创建集合
        List<Person> list = new ArrayList<>();
        //添加Person对象
        list.add(new Person("公孙嘏", 20));
        list.add(new Person("郑等待", 18));
        list.add(new Person("丁巴寿", 22));
        //使用比较器排序（对集合中的Person对象按照年龄从小到大的顺序排序）
        //单独定义Comparator实现类，然后创建实现类对象。
        Collections.sort(list, new Rule());

        //使用匿名内部类完成比较器排序

        /*Collections.sort(list, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge() - o2.getAge();
            }
        });*/


        /*
            (参数类型 参数名) -> {
                方法体;
                return 返回值;
            }
         */
        //使用Lambda表达式完成比较器排序

        Collections.sort(list, (Person o1, Person o2) -> {
            return o1.getAge() - o2.getAge();
        });


        //使用Lambda表达式省略格式完成比较器排序
        //Collections.sort(list, (o1, o2) -> o1.getAge() - o2.getAge());


        //输出结果
        System.out.println(list);
    }
}
```

```java
import java.util.Comparator;

public class Rule implements Comparator<Person> {
    @Override
    public int compare(Person o1, Person o2) {
        return o1.getAge() - o2.getAge();
    }
}
public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

### 4.Lambda表达式简化写法

```java
Lambda标准格式：
        (参数类型 参数名) -> {
        方法体;
        return 返回值;
        }

        省略规则：
        1. 小括号中的参数类型可以省略。
        2. 如果小括号中只有一个参数，那么可以省略小括号。
        3. 如果大括号中只有一条语句，那么可以省略大括号，return，以及分号。
```

```java
public class Demo04SimpleLambda {
    public static void main(String[] args) {
        //使用Lambda标准格式完成多线程
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "执行了");
        }).start();
        //使用Lambda表达式省略格式完成多线程
        new Thread(() -> System.out.println(Thread.currentThread().getName() + "执行了")).start();
    }
}
```

### 5.Lambda表达式使用前提

```java
Lambda表达式的使用前提
    1. 必须要有接口（不能是抽象类），接口中有且仅有一个需要被重写的抽象方法。（比如Runnable或Comparator）
    2. 必须支持上下文推导。 要能够推导出来Lambda表达式表示的是哪个接口中的哪个方法。
       最常用的上下文推导的方式是使用函数式接口当做方法参数，然后传递Lambda表达式。


注意：
    如果一个接口中有且仅有一个需要被重写的抽象方法，那么该接口也叫做函数式接口。
    public class Demo05BeforLambda {
    public static void main(String[] args) {
        //() -> System.out.println(Thread.currentThread().getName() + "执行了");

        //因为Thread构造方法需要传递Runnable接口类型的参数，而Runnable接口中只有一个需要被重写的抽象方法叫做run
        //所以向Thread构造方法位置传递的Lambda表示必然表示Runnable接口中的run方法。
        new Thread(() -> System.out.println(Thread.currentThread().getName() + "执行了")).start();
    }
}
```





## 第六章 Stream

### 1.传统方式操作集合的弊端

```java
import java.util.ArrayList;
import java.util.List;
/*操作要求：
        1. 首先筛选所有姓张的人；
        2. 然后筛选名字有三个字的人；
        3. 最后进行对结果进行打印输出。*/
public class Demo01PrintList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        //1. 首先筛选所有姓张的人；
        //定义集合，保存本次筛选后的结果
        List<String> zhangList = new ArrayList<>();
        //遍历集合，拿到每一个元素，判断是否以张开头
        for (String str : list) {
            if(str.startsWith("张")) {
                zhangList.add(str);
            }
        }
        // 2. 然后筛选名字有三个字的人；
        //定义集合，保存本次筛选后的结果
        List<String> threeList = new ArrayList<>();
        //遍历上次筛选后的结果，拿到里面的每一个元素，判断是否是三个字
        for (String str : zhangList) {
            if(str.length() == 3) {
                threeList.add(str);
            }
        }
        //3. 最后进行对结果进行打印输出。
        for (String str : threeList) {
            System.out.println(str);
        }
        System.out.println("===================");
        // Stream体验
        //list.stream().filter(s->s.startsWith("张")).filter(s->s.length()==3).forEach(s-> System.out.println(s));
        list.stream().filter(s->s.startsWith("张")).filter(s->s.length()==3).forEach(System.out::println);
    }
}
```

![](https://p.pstatp.com/origin/ff290002cbb247d81abf)

### 2.单列集合获取流

```java
Stream<T>是一个接口，该接口表示流。

    获取流的两种方式
        1. 通过Collection集合（单列集合）调用stream()方法获取。【根据单列集合获取】
        2. 通过Stream中的静态方法根据数组获取流。【根据数组获取】

    Collection中获取流的方法：
        Stream<E> stream()：获取集合对应的流。
        import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class Demo02CollectionGetStream {
    public static void main(String[] args) {
        // 创建集合
        List<String> list  = new ArrayList<>();
        list.add("hello");
        list.add("world");
        list.add("java");
        // 通过集合获取流
        Stream<String> stream = list.stream();
        // 输出
        // 将流转成数组,用数组的工具类将数组转成字符串,并使用println输出
        System.out.println(Arrays.toString(stream.toArray()));
    }
}

```

### 3.根据数组获取流

```java
在Stream中有一个静态方法，可以根据数组获取流。

    Stream中根据数组获取流的方法：
        static <T> Stream<T> of(T... values)：根据数组或多个元素获取Stream流。
        使用引用类型数据类型.
        
import java.util.Arrays;
import java.util.stream.Stream;

public class Demo02ArrayGetStream {
    public static void main(String[] args) {
        // 创建数组
        // String[] strArr = {"aa","bb","cc"};
        // 根据数组获取流
        // Stream<String> stream = Stream.of(strArr);

        //of方法不仅可以根据数组获取流，也可以根据多个元素获取流
        Stream<String> stream = Stream.of("aa","bb","cc");

        // 输出
        System.out.println(Arrays.toString(stream.toArray()));

    }
}
```

### 4.Stream的常用方法

流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：

 `终结方法`：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式 调用。本小节中，终结方法包括 count 和 forEach 方法。 

`非终结方法`：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。）

函数拼接与终结方法 在上述介绍的各种方法中，凡是返回值仍然为 Stream 接口的为函数拼接方法，它们支持链式调用；而返回值不再
为 Stream 接口的为终结方法，不再支持链式调用。如下表所示：

| 方法名  | 作用       | 方法种类 | 是否支持链式调用 |
| ------- | ---------- | -------- | ---------------- |
| count   | 统计个数   | 终结     | 否               |
| forEach | 逐一处理   | 终结     | 否               |
| filter  | 过滤       | 函数拼接 | 是               |
| limit   | 取用前几个 | 函数拼接 | 是               |
| skip    | 跳过前几个 | 函数拼接 | 是               |
| map     | 映射       | 函数拼接 | 是               |
| concat  | 组合       | 函数拼接 | 是               |

#### 4.1forEach

```java
在Stream中有一个方法叫做forEach，可以对流中的元素进行逐一处理，逐一操作
    void forEach(Consumer action)：对流中的每一个元素进行逐一操作，逐一处理。参数Consumer表示处理规则。

Consumer是一个函数式接口，这个接口中只有一个抽象方法
    void accept(T t)：对数据进行操作，进行处理。


forEach方法的参数是Consumer函数式接口，那么可以传递Lambda表达式，这个Lambda表达式表示的是Consumer接口中唯一的一个抽象方法
accept的内容，我们要在Lambda表达式中编写操作规则。
    import java.util.stream.Stream;
public class Demo04ForEach {
    public static void main(String[] args) {
        // 获取Stream流
        Stream<String> stream = Stream.of("aa", "bb", "cc", "dd", "ee");
        // 对流中的每一个元素进行逐一处理
        stream.forEach(s -> System.out.println(s));
    }
}
```

## 总结







































