<center>反射、注解、动态代理</center>

## 今日内容

+ 反射
  + 加载器
  + 类加载机制
+ 反射
  + class对象获取
  + 常用方法
  + 通过反射获取构造方法
  + 通过返回获取成员方法







## 第一章 反射



### 1.类的加载时机

当我们第一次使用某个类时，这个类会加载到方法区

    1.  创建类的实例。
       2.  类的静态变量，或者为静态变量赋值。
       3.  类的静态方法。
       4.  使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。
       5.   初始化某个类的子类。
       6.  直接使用java.exe命令来运行某个主类。

以上六种情况的任何一种，都可以导致JVM将一个类加载到方法区。

类是由类加载器加载的。

### 2.类加载机制

1. 启动类加载器(Bootstrap ClassLoader)：用于加载系统类库<JAVA_HOME>\bin目录下的
   class，例如：rt.jar。内容包括:String  object...
2. 扩展类加载器(Extension ClassLoader)：用于加载扩展类库<JAVA_HOME>\lib\ext目录下的
   class。
3. 应用程序类加载器(Application ClassLoader)：用于加载我们自定义类的加载器。

```java
/*
如果想要获取加载读类的类加载器，可以使用下面代码
    Person.class.getClassLoader()

启动类加载器是扩展类加载器的 父加载器
扩展类加载器是应用类加载器的 父加载器
 */

public class Demo01ClassLoaderTest {
    public static void main(String[] args) {
        System.out.println(Person.class.getClassLoader().getParent());
    }
}
```

### 3双亲委派模型

![](https://img01.sogoucdn.com/app/a/100520146/976316EE8228684C2EB602F0FC0205E9)

## 第二章 反射

### 1概念

反射：Java中的反射是一种操作机制，我们利用反射可以在程序运行时期获取到一个类的构造方法，成员方法，成员变量，并进行使用。

原理: 反射操作的就是Class类型的对象，当我们使用一个类时，这个类会由类加载器加载到方法区，同时会给这个类创建Class类型的对象。这个Class类型的对象是用来描述该类的，会保存该类的信息，所以我们可以通过这个Class对象获取到类的成员变量，成员方法，构造方法等进行使用。

![](https://img03.sogoucdn.com/app/a/100520146/5DFA4A54A231AFAC8148BB7F422A6A28)



### 2.Class对象的获取方式

1. 通过对象调用getClass方法获取
            Class getClass()：获取Class对象
        2. 通过类调用class属性获取（最简单）
            类名.class
        3. 通过Class的静态方法forName获取（最常用，最灵活）
            static Class forName(String className)：可以根据全类名（包含包的类名）获取类的Class对象

    一个类的Class对象只有一个，不管获取几次，获取的都是同一个Class对象。

```java
public class Demo01GetClass {
    public static void main(String[] args) throws ClassNotFoundException {
        // 1. 通过对象调用getClass方法获取
        Person p = new Person();
        Class<? extends Person> clazz = p.getClass();
        System.out.println(clazz);
        // class cn.com.mryhl.demo02_refiect.Person
        // 2. 通过类调用class属性获取（最简单）
        Class<Person> personClass = Person.class;
        System.out.println(personClass);
        // 3. 通过Class的静态方法forName获取（最常用，最灵活）
        Class<?> person = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        System.out.println(person);
		// 验证3次获取的对象是否是同一个
        System.out.println(clazz == personClass); 
    }
}
```



### 3.Class类常用方法

 String getName()：获取类的全限定类名（包含包的的类名）
 String getSimpleName(): 获取类的简单类名（不包含包的类名）

```java
public class Demo02ClassMethod {
    public static void main(String[] args) {
        // 获取Person类的Class
        Class clazz = Person.class;
        // String getName()：获取类的全限定类名（包含包的的类名）
        System.out.println(clazz.getName());
        // String getSimpleName(): 获取类的简单类名（不包含包的类名）
        System.out.println(clazz.getSimpleName());
    }
}
```

### 4.使用反射获取的构造方法

在Class中有一些方法可以获取到类的构造方法：
    Constructor[] getConstructors()：获取到类中所有的构造方法。
    Constructor getConstructor(Class... parameterTypes)：获取到类中指定的构造方法。 参数表示要获取的构造方法的参数列表。
    上面的方法只能获取到类中public权限的构造方法，其他权限无法获取。

Constructor表示构造方法，里面的功能：
    T newInstance(Object... initargs)：通过该构造方法创建对象。
        参数initargs：表示通过构造方法创建对象时传递的实际参数。
        返回值：创建出来的对象

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
public class Demo03Constructor {
    public static void main(String[] args) throws ClassNotFoundException {
        method();
    }
    /*
    Constructor getConstructor(Class... parameterTypes)：获取到类中指定的构造方法。 参数表示要获取的构造方法的参数列表。
    上面的方法只能获取到类中public权限的构造方法，其他权限无法获取。
       要求：获取Person类中的空参数的构造方法，并使用该构造方法创建对象
     */
    
    public static void method2() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, InvocationTargetException {
        //获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        //获取Person类空参数的构造方法
        //public Person()：空参构造
        //因为getConstructor方法参数没有传递任何内容，所以表示我们获取的是空参数的构造方法
        Constructor c = clazz.getConstructor();
        //通过获取到的构造方法调用newInstance方法，使用获取到的构造方法创建对象
        //newInstance方法的参数表示使用构造方法创建对象时传递的实际参数，因为使用空参数的构造方法创建对象，所以不需要传递任何实际参数。所以newInstance方法参数留空不写
        //newInstance方法参数留空不写表示没有传递任何实际参数
        Object obj = c.newInstance();
        System.out.println(obj);
    }




    /*
    Constructor[] getConstructors()：获取到类中所有的构造方法。
     */

    public static void method() throws ClassNotFoundException {
        // 获取Person类的Class
        Class<?> clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        // 获取该类的构造方法
        Constructor[] cs = clazz.getConstructors();
        //遍历数组，拿到每一个构造方法并输出
        for (Constructor c : cs) {
            System.out.println(c);
        }
    }
}
```

### 5.带参

```java
public class Demo04Constructor {
    /**
    *Constructor getConstructor(Class... parameterTypes)：获取到类中指定的构造方法。 参数表示要获取的构造方法的参数列表。
     *
     * 要求：通过反射获须person类的带参数的构造方法，并根据读构造方法创建对象
     *
     * */
    public static void main(String[] args) throws Exception {
        //获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        // 获取带参数的构造方法
        // Person(String name,int age)
        // 因为调用getConstructor方法第一个参数传递的是String.class，第二个是int.class，表示要获取的构造方法有两个参数，第一个是String，第二个是int
        Constructor c = clazz.getConstructor(String.class,int.class);
        // 根据构造方法创建对象
        // new Person("张三",13)
        // 因为在调用newInstance方法的时候传递的两个参数分别是张三和13,所以表示调用构造方法时传递的实际参数为张三13
        Object o = c.newInstance("张三", 13);// 相当于之前的new Person("张三",13)
        System.out.println(o);

    }
}
```

### 6.暴力反射

暴力反射（不推荐，会破坏封装性）
暴力反射可以获取到类中任何权限（包括私有）的成员并进行使用。

在Class中，有一些方法可以获取到类中的所有权限的构造方法：
Constructor[] getDeclaredConstructors()：获取类中所有的构造方法
Constructor getDeclaredConstructor(Class... parameterTypes)：获取类中指定的构造方法，参数是构造方法的参数列表
上面的方法可以获取到任何权限的构造方法。

通过上面的方法虽然可以获取到私有的成员，但是不能直接使用。
因为Java中有一个权限检查机制，私有的东西是不能在外面使用的。
我们可以取消这个权限检查机制。

反射有关的类
Constructor：构造方法
Method：成员方法
Field：成员变量

上面这三个类都有一个父类叫做AccessibleObject，在AccessibleObject中有一个方法可以取消检查机制。
void setAccessible(boolean flag)：如果参数是true表示取消权限检查

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Demo05Constructor {
    public static void main(String[] args) throws Exception {
        //method();
        method2();
    }

    /*
    Constructor getDeclaredConstructor(Class... parameterTypes)：获取类中指定的构造方法，参数是构造方法的参数列表
    要求：使用反射获取私有的构造方法，并创建对象

     */

    public static void method2() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, InvocationTargetException {
        //获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        //获取Person类空参数的构造方法
        //public Person()：空参构造
        //因为getConstructor方法参数没有传递任何内容，所以表示我们获取的是空参数的构造方法
        Constructor c = clazz.getDeclaredConstructor(String.class);
        //通过获取到的构造方法调用newInstance方法，使用获取到的构造方法创建对象
        // 取消权限检查机制
        c.setAccessible(true);
        Object obj = c.newInstance("张三丰");
        System.out.println(obj);
    }




    /*
    Constructor[] getDeclaredConstructors()：获取到类中所有的构造方法。
     */

    public static void method() throws Exception {
        // 获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        // 获取该类的构造方法
        Constructor[] cs = clazz.getDeclaredConstructors();
        //遍历数组，拿到每一个构造方法并输出
        for (Constructor c : cs) {
            System.out.println(c);
        }
    }
}

```

### 7.简单的创建对象方法

```java
/*
在CLass中有一个方法叫做newInstance,可以十分方便的创建对象
T newInstance():使用空参数的构造方法创建对象。
如果要通过空参数的构造方法创建对象，那么不需要像之前那样先获取构造方法，然后再通过构造方法创建对象了。
我们可以通过class直接调用newInstance方法，利用空参数的构造方法对象。
 */

public class Demo06NewInstance {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        // 获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        //直接调用newInstance创建对象
        Object obj = clazz.newInstance( ) ;
        //输出结果
        System.out.println(obj);
    }
}
```

### 8.使用反射获取成员方法并使用。

在Class中有一些功能，可以获取到类中的成员方法
    Method[] getMethods()：获取到类中所有的成员方法。
    Method getMethod(String name, Class... parameterTypes)：获取到类中指定的成员方法。参数name表示要获取的方法名，参数parameterTypes表示要获取的成员方法的参数列表。
    上面的两个功能只能获取到类中public权限的成员方法，其他权限无法获取。

Method表示成员方法，里面的功能：
    Object invoke(Object obj, Object... args)：让该方法执行。
            参数obj：表示通过哪个对象调用了该方法。如果是调用的静态方法，该参数可以是null。
            参数args：表示调用该方法时传递的实际参数
            返回值：方法调用的返回值

```java
import java.lang.reflect.Method;

public class Demo07Method {
    public static void main(String[] args) throws Exception {
        method2();
    }

    /**
     * Method getMethod(String name, Class... parameterTypes)：获取到类中指定的成员方法。参数name表示要获取的方法名，参数parameterTypes表示要获取的成员方法的参数列表。
     */
    public static void method2() throws Exception {
        // 获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        // 获取成员方法
        //getMethod方法第一个参数传递的是sleep,表示获取的方法他的名字是sleep
        //getMethod方法第二个参数是可变参数，该参数位置我们没有传递任何东西，表示获取的方法是空参数的方法
        Method method1 = clazz.getMethod("sleep");
        //System.out.println(method1);
        // 创建Person对象
        Object o = clazz.newInstance();
        // 调用invoke,让方法执行
        // 因为通过method1调用incoke方法,method1表示sleep方法,所以表示sleep执行了
        // 因为invoke方法第一个参数传递的是obj,表示通过obj调用了
        // 因为invoke方法第二个参数没有传递任何数据，所以表示调用sLeep方法时，没有传递任何内容
        method1.invoke(o);
    }


    /**
     * Method[] getMethods()：获取到类中所有的成员方法。
     */
    public static void method() throws Exception {
        // 获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        // 获取成员方法
        Method[] methods = clazz.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }
    }
}
```

```java
import java.lang.reflect.Method;

public class Demo08Method {
    /*
        要求：获取有参数的成员方法并调用
        public String eat(string food)
     */

    public static void main(String[] args) throws Exception {
        // 获取Person类的Class
        Class clazz = Class.forName("cn.com.mryhl.demo02_refiect.Person");
        // 通过class对象,获取指定的成员方法
        // Method getMethod(String name, Class... parameterTypes)：获取到类中指定的成员方法。参数name表示要获取的方法名，参数parameterTypes表示要获取的成员方法的参数列表。
        // 第一个参数传递的是eat,表示方法名是eat
        // 第二个参数是可变参数,表示参数类别,传的是String.class,表示字符串
        Method eat = clazz.getMethod("eat", String.class);
        Object o = clazz.newInstance();
        //调用invoke,让eat方法执行
        //Object invoke(Object obj, Object...args):让该方法执行
        //因为eat表示的是eat方法，所以通过eat调用invoke方法时让eat方法执行
        //因为invoke方法第一个参数是o,表示通过o调用了eat方法
        //invoke方法第二个参数是可变参数，我们可以传递任意个数据
        // 返回值就是eat的结果
        Object o1 = eat.invoke(o, "法式鹅肝就米饭");
        System.out.println(o1);
    }
}
```

### 9.使用反射操作成员变量（了解）

在Class中有一些方法可以获取到类中的成员变量
    Field[] getFields()：获取类中所有的成员变量
    Field getField(String name)：获取类中指定的成员变量，参数是成员变量的名字。
        上面的两个方法只能获取public权限的成员变量，其他权限无法获取。

Field表示成员变量，里面功能：
    void set(Object obj, Object value):给成员变量赋值。
        参数obj：表示给哪个对象的成员变量赋值。
        参数value：将该成员变量赋成什么值

Object get(Object obj)：获取成员变量的值。
    参数obj：表示获取哪个对象的成员变量的值。
    返回值：获取到的结果

```java
import java.lang.reflect.Field;
public class Demo09ReflectField {
    //获取Person类的hobby属性，然后进行赋值取值操作

    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException {
        //获取Person类的Class
        Class clazz = Class.forName("com.itheima.demo01_reflect.Person");
        //获取Person类中的hobby属性
        Field field = clazz.getField("hobby");
        //创建Person对象
        Object obj = clazz.newInstance();
        //给对象hobby属性赋值
        field.set(obj, "写代码");
        //相当于 obj.hobby = "写代码";
        System.out.println(obj);
        //获取hobby属性的值
        //获取obj的hobby属性的值
        Object result = field.get(obj);
        System.out.println(result);
    }
}
```

### 10.练习

 将类名与方法名放到文件中,通过读取文件的方法决定创建哪个类调用哪个方法
步骤：
    1.创建配置文件，保存类名和方法名
    2.创建Properties集合
    3.创建输入流
    4.调用Load方法，将文件中的键值对加载到Properties集合中
    5.通过Properties集合根据键获取值。
    6.获取该类的CLass对象
    7.通过CLass调用getMethod,获取对应的方法
    8.让方法执行。

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

public class Demo01Test {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {
        // 步骤：
        // 1.创建配置文件，保存类名和方法名
        // 2.创建Properties集合
        Properties p = new Properties();
        // 3.创建输入流
        FileInputStream is = new FileInputStream("day17\\config.properties");

        // 4.调用Load方法，将文件中的键值对加载到Properties集合中
        p.load(is);
        is.close();
        // 5.通过Properties集合根据键获取值。
        String className = p.getProperty("className");
        String methodName = p.getProperty("methodName");
        // 6.获取该类的CLass对象
        Class clazz = Class.forName(className);
        // 7.通过CLass调用getMethod,获取对应的方法
        Method m = clazz.getMethod(methodName);
        // 8.让方法执行。
        Object obj = clazz.newInstance();
        m.invoke(obj);


    }
}
```